# Project 3: Stack Growth

이 프로젝트는 xv6 운영체제에서 페이지 폴트를 처리하여 스택 공간이 동적으로 확장되도록 구현하는 것을 목표로 합니다.

---

## 목차

- [프로젝트 개요](#프로젝트-개요)
- [가상 메모리와 페이지 테이블](#가상-메모리와-페이지-테이블)
- [페이지 폴트 핸들러 구현](#페이지-폴트-핸들러-구현)
- [테스트 프로그램](#테스트-프로그램)
- [참고 자료](#참고-자료)

---

## 프로젝트 개요

이 프로젝트에서는 xv6 운영체제의 스택이 초기에는 1개의 페이지로 시작하지만, 동적으로 최대 4개의 페이지까지 확장되도록 합니다. 이를 위해 페이지 폴트가 발생할 때 새로운 페이지를 할당하는 페이지 폴트 핸들러를 구현해야 합니다. 



## 가상 메모리와 페이지 테이블

xv6의 가상 메모리 구조는 `memlayout.h`에 정의되어 있으며, 사용자 공간과 커널 공간으로 나뉩니다. 페이지 폴트가 발생하면, CPU는 페이지 폴트 주소를 `CR2` 레지스터에 저장하고, 인터럽트 14를 통해 페이지 폴트 핸들러를 호출합니다.



## 페이지 폴트 핸들러 구현

페이지 폴트 핸들러는 `trap.c` 파일에 구현됩니다. 구현 세부 사항은 다음과 같습니다:

1. **페이지 폴트 주소 확인**:
   - `rcr2()` 함수를 통해 페이지 폴트가 발생한 가상 주소를 가져옵니다.

2. **유효성 검사**:
   - 페이지 폴트가 발생한 주소가 스택의 현재 top 페이지 바로 다음에 위치하고, 최대 스택 크기(4페이지)를 초과하지 않는지 확인합니다.

3. **새로운 페이지 할당**:
   - 조건을 충족할 경우, 새로운 물리 페이지를 할당하고 페이지 테이블에 매핑합니다.
   - 정상적으로 페이지 폴트가 처리될 경우 `[Pagefault] Allocate new page!` 메시지를 출력하고, 잘못된 접근 시 `[Pagefault] Invalid access!` 메시지를 출력합니다.

4. **스택 오버플로우 처리**:
   - 스택 포인터가 가드 페이지에 도달하면 프로세스를 종료하여 스택 오버플로우를 방지합니다.



## 테스트 프로그램

테스트 프로그램을 작성하여 페이지 폴트 핸들러가 올바르게 작동하는지 검증합니다. 잘못된 메모리 접근을 시도하여 페이지 폴트가 발생할 때, 올바른 메시지가 출력되는지 확인합니다.


## 참고 자료

- xv6 소스 코드: [GitHub 링크](https://github.com/mit-pdos/xv6-public)
- xv6 해설서: [xv6 commentary PDF](https://pdos.csail.mit.edu/6.828/2018/xv6/book-rev11.pdf)
- xv6 관련 참고서적: [xv6 source booklet PDF](https://pdos.csail.mit.edu/6.828/2018/xv6/xv6-rev11.pdf)



